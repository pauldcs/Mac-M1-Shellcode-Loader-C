#include <sys/mman.h>
#include <sys/wait.h>
#include <stdbool.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

char	__sc[256] =
{
	0xe0, 0x45, 0x8c, 0xd2, 0x20, 0xcd, 0xad, 0xf2,
	0xe0, 0x65, 0xce, 0xf2, 0x00, 0x0d, 0xe0, 0xf2,
	0xe0, 0x0f, 0x1c, 0xf8, 0xe0, 0x03, 0x00, 0x91,
	0xa1, 0x65, 0x8c, 0xd2, 0xe1, 0x0b, 0x00, 0xf9,
	0xe1, 0x43, 0x00, 0x91, 0xe2, 0x00, 0x00, 0x10,
	0xe0, 0x07, 0x02, 0xa9, 0xe2, 0x7f, 0x03, 0xa9,
	0xe2, 0x03, 0x1f, 0xaa, 0xe1, 0x83, 0x00, 0x91,
	0x70, 0x07, 0x80, 0xd2, 0x01, 0x00, 0x00, 0xd4,
};

static void	__run(char *cmd)
{
	int		(*ptr)(void);
	void	*buf;
	size_t	sc_len;

	sc_len = sizeof(__sc);
	if (strlen(cmd) >= sc_len - 64)
		return ;
	strlcpy(&__sc[64], cmd, sc_len - 64);
	buf = mmap(0, 0x100, PROT_WRITE | PROT_READ, MAP_ANON | MAP_PRIVATE, -1, 0);
	if (buf != MAP_FAILED)
	{
		ptr = memcpy(buf, __sc, sc_len);
		if (mprotect(buf, 0x100, PROT_EXEC | PROT_READ) == 0)
			ptr();
	}
}

int	__load(void)
{
	char	*cmd = "echo abc";
	pid_t	id;
	int		ret;
	
	id = fork();
	if (id < 0)
		return (EXIT_FAILURE);
	else if (id == 0)
	{
		__run(cmd);
		exit(EXIT_FAILURE);
	}
	waitpid(id, &ret, 0);
	return (ret);
}
